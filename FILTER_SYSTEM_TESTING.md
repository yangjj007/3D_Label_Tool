# 模型过滤系统测试指南

## 测试前准备

### 1. 环境配置
```bash
# 确保.env文件存在
cp env.template .env

# 安装依赖（如果还没安装）
npm install

# 启动服务
npm run dev:full
```

### 2. 测试数据准备
- 在 `files/labeled_files/` 目录中准备至少5-10个已打标的3D模型文件
- 确保模型格式为 GLB/GLTF
- 模型大小建议在1MB-50MB之间（用于测试）

## 测试用例

### 测试1: 材质计数准确性 ✓

**目的**: 验证材质数量统计的准确性

**步骤**:
1. 手动打开一个GLB文件（使用Blender或glTF Viewer）
2. 统计材质数量
3. 运行"开始计算指标"
4. 检查JSON文件中的 `materialCount` 字段

**预期结果**:
- 自动计算的材质数应等于手动统计的数量

**验证方法**:
```bash
# 查看JSON文件
cat files/labeled_files/your-model.glb.json | grep materialCount
```

---

### 测试2: 体素化正确性 ✓

**目的**: 验证体素化算法的合理性

**步骤**:
1. 选择一个简单模型（如立方体）
2. 计算指标（分辨率64）
3. 检查体素数据

**预期结果**:
- `occupiedVoxels` > 0
- `surfaceVoxels` < `occupiedVoxels`
- `surfaceVoxels` / `occupiedVoxels` (VSC) 应在 0-1 之间
- 简单模型的VSC应较低（0.1-0.4）
- 复杂模型的VSC应较高（0.6-1.0）

**验证命令**:
```javascript
// 在浏览器控制台执行
const metadata = await fetch('/api/files?type=labeled&page=1&pageSize=1')
  .then(r => r.json());
console.log(metadata.files[0].filterMetrics);
```

---

### 测试3: 断点续传 ✓

**目的**: 验证计算可以中断后继续

**步骤**:
1. 开始计算指标（确保有多个文件）
2. 计算进行到50%时关闭浏览器标签页
3. 重新打开页面
4. 再次点击"开始计算指标"

**预期结果**:
- 已计算过的文件应被跳过
- 只计算剩余未完成的文件
- 总计算文件数 = 第一次计算数 + 第二次计算数

**验证方法**:
- 查看控制台日志中的 "跳过文件" 消息
- 检查进度统计中的 "已跳过" 数量

---

### 测试4: 分辨率变化检测 ✓

**目的**: 验证分辨率变化时会重新计算

**步骤**:
1. 使用分辨率64计算指标
2. 修改分辨率为32
3. 重新计算

**预期结果**:
- 系统检测到分辨率不匹配
- 所有文件重新计算
- JSON中 `voxelResolution` 更新为32
- 指标值会有变化

---

### 测试5: 过滤准确性 ✓

**目的**: 验证过滤逻辑正确

**测试数据**:
假设有3个模型：
- Model A: 材质=3, VVD=5.0, VFC=3.0, VSC=0.5
- Model B: 材质=6, VVD=4.0, VFC=2.5, VSC=0.3
- Model C: 材质=4, VVD=8.0, VFC=4.0, VSC=0.7

**过滤条件**:
```
材质个数: 2-5
VVD: 3.0-10.0
VFC: 2.0-5.0
VSC: 0.2-0.8
```

**预期结果**:
- Model A: ✓ 通过（所有指标都在范围内）
- Model B: ✗ 未通过（材质=6超出范围）
- Model C: ✓ 通过（所有指标都在范围内）

**验证方法**:
1. 执行过滤
2. 检查 `files/filtered_files/` 目录
3. 应只包含 Model A 和 Model C

---

### 测试6: 统计功能 ✓

**目的**: 验证统计分析准确性

**步骤**:
1. 计算至少10个模型的指标
2. 切换到"统计分析"选项卡
3. 点击"加载统计数据"
4. 检查统计表格和密度图

**预期结果**:
- 样本数正确
- 最小值 ≤ 均值 ≤ 最大值
- 中位数接近均值（正态分布情况下）
- 密度图显示正常（无报错）

**手动验证**:
```javascript
// 计算均值验证
const values = [v1, v2, v3, ...]; // 从JSON文件提取
const mean = values.reduce((a,b) => a+b) / values.length;
// 对比统计表中的均值
```

---

### 测试7: 边界情况 - 超大模型 ⚠️

**目的**: 测试处理大文件的能力

**步骤**:
1. 准备一个>100MB的GLB文件
2. 尝试计算指标

**预期结果**:
- 计算成功（可能较慢）
- 或者优雅地失败并给出错误提示
- 不应导致浏览器崩溃

**注意事项**:
- 可能需要较长时间（>1分钟）
- 监控浏览器内存使用

---

### 测试8: 边界情况 - 超多面片 ⚠️

**目的**: 测试高复杂度模型

**步骤**:
1. 准备一个面片数>100万的模型
2. 计算指标

**预期结果**:
- VVD和VFC值会很高
- 计算可能较慢但应完成
- JSON正确保存

---

### 测试9: 边界情况 - 损坏文件 ✓

**目的**: 测试错误处理

**步骤**:
1. 创建一个损坏的GLB文件（截断文件内容）
2. 放入labeled_files目录
3. 尝试计算指标

**预期结果**:
- 应捕获错误
- 在进度统计中显示"失败: 1"
- 继续处理其他文件
- 不应导致整个计算流程中断

---

### 测试10: 并发处理 ✓

**目的**: 验证并发控制

**步骤**:
1. 准备20个以上的模型文件
2. 设置并发数为3
3. 开始计算
4. 观察浏览器资源使用

**预期结果**:
- 同时处理的文件数不超过3
- 内存使用保持稳定
- 不会出现内存泄漏

**监控方法**:
- Chrome DevTools -> Performance Monitor
- 观察JS Heap大小
- 应该看到锯齿状（加载-释放-加载-释放）

---

### 测试11: UI响应性 ✓

**目的**: 确保计算时UI不卡顿

**步骤**:
1. 开始计算指标
2. 在计算过程中：
   - 切换标签页
   - 滚动文件列表
   - 打开其他对话框

**预期结果**:
- UI保持响应
- 进度条实时更新
- 其他操作不受影响

---

### 测试12: 过滤结果验证 ✓

**目的**: 验证filtered_files内容正确

**步骤**:
1. 执行过滤
2. 检查filtered_files目录
3. 验证每个文件

**验证脚本**:
```bash
# 列出过滤后的文件
ls -lh files/filtered_files/

# 对每个文件验证JSON
for file in files/filtered_files/*.json; do
  echo "Checking $file"
  cat "$file" | jq '.filterMetrics'
done
```

**预期**:
- 每个文件都有对应的JSON
- JSON包含 `filteredAt` 时间戳
- 所有指标都在设定的阈值范围内

---

## 性能基准测试

### 小规模测试（10个文件）
- **模型大小**: 平均5MB
- **分辨率**: 64
- **指标**: VVD, VFC, VSC
- **预期时间**: 30-60秒
- **内存**: <500MB

### 中等规模测试（50个文件）
- **模型大小**: 平均10MB
- **分辨率**: 64
- **指标**: VVD, VFC, VSC
- **预期时间**: 3-5分钟
- **内存**: <1GB

### 大规模测试（100+个文件）
- **建议**: 分批处理
- **并发数**: 3
- **预期时间**: 10-15分钟
- **内存**: 应保持稳定，不超过1.5GB

## 自动化测试建议

### 单元测试（可选）
```javascript
// 测试体素化函数
import { voxelizeModel } from '@/utils/voxelization';

describe('Voxelization', () => {
  it('should return valid voxel data', () => {
    const model = loadTestModel();
    const result = voxelizeModel(model, 64);
    
    expect(result.occupiedCount).toBeGreaterThan(0);
    expect(result.surfaceCount).toBeLessThanOrEqual(result.occupiedCount);
  });
});
```

### 集成测试清单
- [ ] 后端API响应正常
- [ ] 前端能正确调用API
- [ ] 文件上传下载正常
- [ ] JSON读写正确
- [ ] 过滤逻辑准确

## 测试报告模板

```markdown
## 测试报告

**测试日期**: 2025-12-18
**测试人员**: [姓名]
**测试环境**: Chrome 120, Windows 11

### 测试结果汇总
- 通过: X/12
- 失败: X/12
- 跳过: X/12

### 详细结果
1. 材质计数准确性: ✓ 通过
2. 体素化正确性: ✓ 通过
3. 断点续传: ✓ 通过
...

### 发现的问题
1. [问题描述]
   - 严重程度: 高/中/低
   - 复现步骤: ...
   - 预期结果: ...
   - 实际结果: ...

### 性能数据
- 平均计算时间: X秒/文件
- 内存使用峰值: XMB
- 浏览器性能: 流畅/卡顿

### 建议
- [改进建议1]
- [改进建议2]
```

## 常见问题

### Q: 测试时浏览器崩溃
A: 
- 降低并发数（改为1-2）
- 减小体素分辨率（改为32）
- 测试更小的模型

### Q: 计算结果不一致
A:
- 检查是否使用了不同的分辨率
- 验证模型文件是否被修改
- 清除缓存重新计算

### Q: 过滤没有找到任何文件
A:
- 检查阈值设置是否过于严格
- 先查看统计数据了解实际分布
- 放宽阈值范围重试

## 下一步

测试通过后：
1. ✓ 更新主README文档
2. ✓ 提交代码到版本控制
3. ✓ 通知团队新功能可用
4. ✓ 收集用户反馈
5. ✓ 规划下一阶段改进

